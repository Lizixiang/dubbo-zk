#一、责任链模式在spring中的应用
##过滤器(Filter)
###通过配置`FilterRegistrationBean`来实现过滤器
1. 实现`javax.servlet.Filter`接口
```
@Component
public class RiskFilter implements Filter {

    private static final Logger logger = LoggerFactory.getLogger(RiskFilter.class);

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
        logger.info("riskFilter入参={}", JSON.toJSONString(request.getParameterMap()));
        chain.doFilter(request, response);
    }
}
```
2. 配置`FilterRegistrationBean`
```
@Configuration
public class FilterConfig {

    @Autowired
    private RiskFilter riskFilter;

    @Bean
    public FilterRegistrationBean logFilter() {
        FilterRegistrationBean<Filter> filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setFilter(riskFilter);
        filterRegistrationBean.addUrlPatterns("/*");
        filterRegistrationBean.setName("logFilter");
        filterRegistrationBean.setOrder(3);
        return filterRegistrationBean;
    }

}
```
3. 接下来看一下如何通过`FilterRegistrationBean`来实现过滤器的
- `FilterRegistrationBean`的继承关系图
![img.png](img.png)
- 通过打断点发现在项目启动时有一个`TomcatStarter`的类（我这边用的是springboot自带的tomcat容器,如果使用其他容器可能略有不同），该类负责在容器启动时初始化`ServletContextInitializer`
![img_1.png](img_1.png)
- 在`ServletContextInitializerBeans`的构造器方法中的`addServletContextInitializerBeans`方法主要负责拿到所有实现`org.springframework.boot.web.servlet.ServletContextInitializer`接口的实现类
![img_2.png](img_2.png)
- 此时拿到实现了`org.springframework.boot.web.servlet.ServletContextInitializer`接口的类并调用`onStartup`方法，该方法位于`RegistrationBean`中。
![img_3.png](img_3.png)
- 然后再调用`DynamicRegistrationBean`类的`register`方法，在该方法中做了两件事情：1.往上下文对象`ApplicationContext`中增加过滤器并保存在`filterDefs`常量中。2.配置过滤器的名称、urlPattern、dispatcherTypes（请求的方式）等等
![img_4.png](img_4.png)
- 至此，过滤器的注册就已经完成了。下面看一下如何调用过滤器的。
- 随便打个请求进来打个断点，找到`ApplicationFilterFactory`的`createFilterChain`方法，该方法首先拿到所有的过滤器，再获取请求的方式（dispatcherType）和请求路径，根据配置的urlPatterns和dispatcherType创建过滤器链
![img_5.png](img_5.png)
- 紧接着执行`ApplicationFilterChain`的doFilter方法，在该方法内部其实就是按照已经排好序的过滤器递归执行`doFilter`，当最后一个过滤器执行完毕后，调用`servlet.service()`走正常的业务逻辑流程
![img_6.png](img_6.png)
###通过`@WebFilter`注解来实现过滤器
- 跟第一种方式不同的是，前者是在配置类中直接创建`FilterRegistrationBean`，而后者是先拿到所有实现了`javax.servlet.Filter`接口的实现类，再统一创建`FilterRegistrationBean`
- `ServletContextInitializerBeans.addAdaptableBeans()`
![img_7.png](img_7.png)
- `addServletContextInitializerBeans`代表第一种配置`FilterRegistrationBean`来实现过滤器的
- `addAdaptableBeans`代表第二种通过`@WebFilter`注解来实现过滤器的
##拦截器(interceptor)